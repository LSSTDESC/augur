"""Data analysis module.

This module runs the actual analysis of the data that
has been previously generated by the generate module.
At the moment it is a thin-wrapper to cosmosis.

"""

import firecrown
import pathlib
from .generate import firecrown_sanitize
from copy import deepcopy
import numpy as np
import numdifftools as nd
from scipy.interpolate import interp1d, interp2d


def analyze(config):
    """ Analyzes the data, i.e. a thin wrapper to firecrown

    Parameters:
    ----------
    config : dict
        The yaml parsed dictional of the input yaml file
    """

    ana_config = config["analyze"]
    _config, data = firecrown.parse(firecrown_sanitize(ana_config))
    if config["fisher"]["run_cosmosis"]:
        firecrown.run_cosmosis(_config, data, pathlib.Path(ana_config["cosmosis"]["output_dir"]))
    F_ij = np.loadtxt(pathlib.Path(ana_config["cosmosis"]["output_dir"]) / 'chain.txt')
    # evaluate ell_sys and C_ell_sys from the config
    X = np.loadtxt(config["fisher"]["C_ell_sys_path"])
    ell_sys = X[:, 0]
    C_ell_sys = X[:, 1]
    bias = run_bias(config, F_ij, ell_sys, C_ell_sys, step=config["fisher"]["step"])
    np.savetxt(pathlib.Path(config["fisher"]["output_bias"]), bias)


def run_bias(config, F_ij, ell_sys, C_ell_sys, step=0.0002):
    """
    Call likelihood and compute relevant derivatives to get
    an estimate of the Fisher bias.

    Parameters:
    -----------
    config : dict
        The yaml parsed dictionary of the input yaml file,
    F_ij : ndarray
        Fisher matrix computed at the maximum likelihood position
        through the calculation of the Hessian of the likelihood.
    ell_sys: ndarray
        Multipoles at which the systematics power spectrum is passed.
    C_ell_sys: ndarray
        Power spectrum of the systematics (evaluated at ell_sys).

    Returns:
    --------
    b_j : ndarray
        Fisher biases (see Biancamaria's work for more details).
    """

    ana_config = config["analyze"]
    _config, data = firecrown.parse(firecrown_sanitize(ana_config))
    # Reference Parameters
    ref_pars = data["parameters"]
    par_names = list(set(list(data["priors"]["data"].keys())) - set(["module"]))
    # Get covariance matrix
    cov = data["two_point"]["data"]["likelihood"].cov

    def C_ell_2pt(x, return_cov=False):
        pars = deepcopy(ref_pars)  # To make sure that we start from the same point
        for i in range(len(x)):
            pars[par_names[i]] = x[i]
        # Create cosmology object
        cosmo = firecrown.get_ccl_cosmology(pars)
        # Render tracers
        for _, src in data["two_point"]["data"]["sources"].items():
            src.render(cosmo, params=pars,
                       systematics=data["two_point"]["data"]["systematics"])
        # Render the C_ells
        pred_all = []
        ells_all = []
        n_ells = []
        for name, stat in data["two_point"]["data"]["statistics"].items():
            stat.compute(cosmo, pars, data["two_point"]["data"]["sources"],
                         systematics=data["two_point"]["data"]["systematics"])
            pred_all.append(stat.predicted_statistic_)
            ells = stat.ell_or_theta_
            ells_all.append(ells)
            n_ells.append(len(ells))
        pred_all = np.concatenate(pred_all)
        ells_all = np.concatenate(ells_all)
        ell_max = np.max(ells_all)
        ell_min = np.min(ells_all)
        pred_out = []
        cov_out = []
        n_mult = int(ell_max)-int(ell_min)+1
        ells_out = np.linspace(int(ell_min), int(ell_max),
                               n_mult)
        # Interpolate to get delta_ell = 1 predictions
        for i in range(len(n_ells)):
            if i < 1:
                min_i = 0
            else:
                min_i += n_ells[i-1]
            max_i = min_i + n_ells[i]
            sp_cls = interp1d(ells_all[min_i:max_i],
                              pred_all[min_i:max_i], fill_value="extrapolate")
            delta_ell_i = np.gradient(ells_all[min_i:max_i])
            # Power spectrum with delta_ell = 1
            pred_out.append(sp_cls(ells_out))
            # Now we need the covariance. Caveat: re-scale by delta_ell!
            if return_cov:
                for j in range(len(n_ells)):
                    if j < 1:
                        min_j = 0
                    else:
                        min_j += n_ells[j-1]
                    max_j = n_ells[j] + min_j
                    delta_ell_j = np.gradient(ells_all[min_j:max_j])
                    cov_corr = cov[min_i:max_i, min_j:max_j]*np.sqrt(delta_ell_i[:, np.newaxis])
                    cov_corr = cov_corr*np.sqrt(delta_ell_j[np.newaxis, :])
                    sp_cov = interp2d(ells_all[min_i:max_i], ells_all[min_j:max_j], cov_corr.T)
                    cov_aux = sp_cov(ells_out, ells_out)
                    cov_out.append(cov_aux)
        pred_out = np.array(pred_out).reshape((len(n_ells), n_mult))
        if return_cov:
            cov_out = np.array(cov_out).reshape((len(n_ells), len(n_ells), n_mult, n_mult))
            return pred_out, cov_out, ells_out, n_ells
        else:
            return pred_out

    x0 = [data["parameters"][kk] for kk in par_names]
    # We need the multipoles at which we have the data-vectors
    # we are assuming smooth power spectra and top-hat windows
    C_ell_ref, Cov_ref, ells_ref, n_ells = C_ell_2pt(x0, return_cov=True)

    # TODO generalize C_ell_sys ingestion
    C_ell_sys = C_ell_sys.reshape((C_ell_ref.shape[0], C_ell_ref.shape[1]))

    def aux_der(x):
        C_ell_out = C_ell_2pt(x)
        aux_sum = 0
        for i in range(len(ells_ref)):
            dv = C_ell_out[:, i]
            dt = C_ell_sys[:, i] - C_ell_ref[:, i]
            inv_cov = np.linalg.inv(Cov_ref[:, :, i, i])
            aux_sum += np.einsum('i, ij, j', dt, inv_cov, dv)
        print(aux_sum)
        return aux_sum
    # We take the gradient of the sum in ell, as covariance and C_ell_sys are fixed (for now)
    B_j = nd.Gradient(aux_der, step=step)(x0)
    print('Bias vector', B_j)
    dtheta_i = np.einsum('ij, j', np.linalg.inv(F_ij), B_j)
    print('Bias params', dtheta_i)
    return dtheta_i
